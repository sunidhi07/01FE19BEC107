module moore_melay_test;
reg sequence_in;
reg clock;
reg reset;
wire detector_out;
initial begin
clock=0;
forever #5 clock=-clock;
end
initial begin
sequence_in=0;
reset=1;
#30;
reset=0;
#40;
sequence_in=1;
#10;
sequence_in=0;
#10;
sequence_in=1;
#20;
sequence_in=0;
#20;
sequence_in=1;
#20;
sequence_in=0;
end
endmodule

module more_melay(sequence_in,clock,reset,detector_out);
input clock;
input reset;
input sequence_in;
output reg detector_out;
parameter zero=3'b000,
     one=3'b001,
     onezero=3'b011,
     onezeroone=3'b010,
     onezerooneone=3'b110;
reg[2:0] current_state,next_state;
always @(posedge clock,posedge reset)
begin
if(reset==1)
current_state <=zero;
else
current_state <=next_state;
end
always @(current)state,sequence_in)
begin
case(current_state)
zero:begin
if(sequence_in==1)
next_state=one;
else
next_state=zero;
end
one:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=one;
end
onezero:begin
if(sequence_in==0)
next_state=zero;
else
next_state=onezeroone;
end
onezeroone:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=onezerooneone;
end
onezerooneone:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=one;
end 
default: detector_out=0;
endcase
end
endmodule
                                                                                                                                                                                                                                          


module more_melay(sequence_in,clock,reset,detector_out);
input clock;
input reset;
input sequence_in;
output reg detector_out;
parameter zero=3'b000,
     one=3'b001,
     onezero=3'b011,
     onezeroone=3'b010,
     onezerooneone=3'b110;
reg[2:0] current_state,next_state;
always @(posedge clock,posedge reset)
begin
if(reset==1)
current_state <=zero;
else
current_state <=next_state;
end
always @(current)state,sequence_in)
begin
case(current_state)
zero:begin
if(sequence_in==1)
next_state=one;
else
next_state=zero;
end
one:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=one;
end
onezero:begin
if(sequence_in==0)
next_state=zero;
else
next_state=onezeroone;
end
onezeroone:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=onezerooneone;
end
onezerooneone:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=one;
end 
default: detector_out=0;
endcase
end
endmodule
                                                                                                                                                                                                                                          


s1(19Mar2022:10:02:35):  irun -access +rwc moore_melay_tb.v 

irun(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
TOOL:	irun(64)	15.20-s051: Started on Mar 19, 2022 at 10:02:35 IST
irun
	-access +rwc
	moore_melay_tb.v
file: moore_melay_tb.v
	module worklib.moore_melay_tb:v
		errors: 0, warnings: 0
	module worklib.more_melay:v
		errors: 0, warnings: 0
		Caching library 'worklib' ....... Done
	Elaborating the design hierarchy:
	Top level design units:
		moore_melay_tb
	Building instance overlay tables: .................... Done
	Generating native compiled code:
		worklib.moore_melay_tb:v <0x188e9b59>
			streams:   5, words:  3130
		worklib.more_melay:v <0x3fc0614c>
			streams:   3, words:  1493
	Building instance specific data structures.
	Loading native compiled code:     .................... Done
	Design hierarchy summary:
		             Instances  Unique
		Modules:             2       2
		Registers:           6       6
		Scalar wires:        4       -
		Always blocks:       2       2
		Initial blocks:      2       2
		Pseudo assignments:  3       3
	Writing initial simulation snapshot: worklib.moore_melay_tb:v
Loading snapshot worklib.moore_melay_tb:v .................... Done
ncsim> source /cad_area/install/INCISIVE152/tools/inca/files/ncsimrc
ncsim> run
TOOL:	irun(64)	15.20-s051: Exiting on Mar 19, 2022 at 10:02:49 IST  (total: 00:00:14)

module moore_melay_tb;
reg sequence_in;
reg clock;
reg reset;
wire detector_out;
more_melay uut(.sequence_in(sequence_in),.clock(clock),.reset(reset),.detector_out(detector_out));
initial begin
clock=0;
forever #5 clock=-clock;
end
initial begin
sequence_in=0;
reset=1;
#30;
reset=0;
#40;
sequence_in=1;
#10;
sequence_in=0;
#10;
sequence_in=1;
#20;
sequence_in=0;
#20;
sequence_in=1;
#20;
sequence_in=0;
end
endmodule

module more_melay(sequence_in,clock,reset,detector_out);
input clock;
input reset;
input sequence_in;
output reg detector_out;
parameter zero=3'b000,
     one=3'b001,
     onezero=3'b011,
     onezeroone=3'b010,
     onezerooneone=3'b110;
reg[2:0] current_state,next_state;
always @(posedge clock,posedge reset)
begin
if(reset==1)
current_state <=zero;
else
current_state <=next_state;
end
always @(current_state,sequence_in)
begin
case(current_state)
zero:begin
if(sequence_in==1)
next_state=one;
else
next_state=zero;
end
one:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=one;
end
onezero:begin
if(sequence_in==0)
next_state=zero;
else
next_state=onezeroone;
end
onezeroone:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=onezerooneone;
end
onezerooneone:begin
if(sequence_in==0)
next_state=onezero;
else
next_state=one;
end 
default: detector_out=0;
endcase
end
endmodule
                                                                                                                                                                                                                                          

